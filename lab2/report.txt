Luke Garrison
Lab 2
Report.txt

This program is meant to be relativley simple from the user's perspetive. The user is only able to interact with the Rational class through main.cpp. Main prompts the user to enter a numerator and a denominator for two Rationals, which are called mass and velocity because they are used to calculate kinetic energy. The user is able to enter any integer for the numerator and denominator. However, a denominator of 0 will cause an error message to be displayed and the denominator will be set to 1 instead. This is basically the extent of the control the user has with the program flow. The program will use the rationals specified by the user and display the calculations that are occuring with the rationals, as well as the answer. The final calculation is a calculation of kinetic energy from the two rationals entered by the user, the first of which is for mass, and the second of which is for velocity. Because this assignment focused on overloading within the design of a class, there is realively little interaction on the user's end, besides creating a demonstration of the Rational class' methods.

My program's design is centered around the design of the Rational Class. The main.cpp is simply a driver program used to demo the methods built into the Rational class. The constructor is a non-default constructor with fallback values of 1, which will create a Rational with a numerator and denominator of 1 if a numerator and denominator is not specified when the object is instantiated. The following public methods are also built into the Rational class. The stream out operator (<<) are overloaded to enable the client to display the rational via cout. This is done by declaring the operator << to be a friend of the class, enabling the overloaded method to access the members of the Rational passed to it directy (instead of having to use getter methods). This is mostly for the convenience of not having to use getter methods and the ability to access the private members of a rational object directly, making the code in the operator<< method more readable. In addition to the overloaded << operator, +, -, *, /, <, and > were overloaded as well. Each of these operators work as expected. (ie, + will add two rationals together, > will check to see if the rational on the left is larger than the rational on the right and return true or false. In the implementation of these overloaded methods, a Rational object is taken in as an argument (because rationalObj1 + rationalObj2 is actually rationalObj1.operator+(rationalObj2)). Because a new rational is created and returned, the rational on the right side of the operator (when the operator is used) should never be altered by the operation, meaning if 1/2 and 2/3 were being added, then neither the 1/2 nor the 2/3 should change in value, but instead a new rational object with the sum should be returned. Because of this, the rational that is passed by reference is declared const, preventing the overloaded method from altering the rational that was taken in as a parameter. If I would have attempted to change the numerator or the denominator of the rational passed into the operator method, I would have been given an error and been able to fix the issue within the method, because I know that that rational should never be altered. This is precisely why I declared it to be const. It would not change the way the program works if I removed the const, but it is a useful safeguard just incase I accidentally have the method alter the arument object unintentionally. This basic structure for each of the operloaded operators is the same. The addition, subtraction, multiplication and division operators each take in a Rational object (reference) and return a Rational object as well. The greater than and less than operators take in a Ratioanl object reference as well but return a bool, true or false. 

The operator+ method works by performing the same set of operations that a human would likely perform to add two fractions with unlike denominators. A common denominator is determined by finding the least common multiple of the denominators of the two rationals. Then, it must be determined what each rational must be multiplied by in order to stay in proportion, yet have the common denominator. This unique multiplier for each rational is vital to determining what the new numerator will be when the rational is mutlplied to attain the common denominator. Thus, the numerator of the sum is calculated by multiplying each rational's numerator by that rational's unique multiplier (determined based on the relation of the origina denominator to the common denominator) and summing them together. The denominator of the sum is simply the common denominator. But then the reduce method is called to attempt to reduce this sum rational to lowest terms (ie 2/4 to 1/2). The operator- method to subtract two rationals works in exactly the same way, only instead of summing the numerators of each rational multiplied by their unique multipliers, the difference's numerator is determined by taking the difference of the numerator of the leftmost rational multiplied by its multiplier and the right rational multiplied by its multiplier. The overloaded multiplication operator is quite straight forward. The numerators of the two rationals are multplied to form the product's numerator, and the denominators of both rationals are also multplied to determine the product's denominator. The product is then reduced with the reduce method. The overloaded division operator is a bit more complicated because it must check for dividing by a rational with a value of 0 (a 0 in the numerator). If this occurs for any reason, then a divide by zero error message is displayed to the user, and the return value is simply set to 0, even though this is not mathematically correct, as creating a way to represent infinity or NaN is quite complicated. Otherwise, the copy of the divisor is made that is the inverse of the divisor, which allows the overlaoded multiplication operator to be used to find the quotient. This is mathematically sound because dividing by the divisor is the same as multiplying by the inverse of the divisor (ie 1/2 / 1/2 is the same as 1/2 * 2/1). I additionally decided to overload the less than and greater than operators to determine if one rational is less than or greater than another rational. To do this, the overlaoded operator copmutes the decimal representation of the rational and compares it to with the decimal representation of the other ratoinal. The regular > or < can be used in this comparison, since two doubles are being compared. Thus, > and < determine whether the overloaded < or > will return true or false. 

Also vital to the class but private helper functions are the lcm, gcd, and reduce methods. The gcd method implements Euclid's algirthm to efficiently determine the GCD of two integers. The lcm method, used primarily in finding a common denominator for the addition and subtraction of rationals utilizes the gcd method. The lcm of two integers is found by multiplying the integers together and dividing their product by the gcd of the two integers. The gcd method is also utilized in the reduce method, which will reduce a rational to its simplest form. The reduce method will first find the gcd of the numerator and denominator. Next, both the numerator and denominator are divided by this GCD. However, then a check is made to see if the denominator is negative or not. If it is, then the negative effectively gets moved to the numerator, as the negative should not be carried on the denominator, as this would make addition and subtraction much more difficult. Besides these private methods, the Rational class simply has two private variables, representing the numerator of the rational and the denominator. 

The main.cpp program simply provides a program to use the Rational class, instantiate Rationals, and perform operations. The user is given the ability to specify two rationals by individually providing the numerator and denominator for each rational. Next, cout is utilize to display the calculation that is about the occur using the user's specified rational, followed by the result of the displayed calculation. The final calculation uses the user's rationals as mass and velocity values respecively, in order to compute the kinetic energy with respect to the given mass and velocity. 

Because this class is modeling Rationals and allows basic mathematically operations such as adding, subtracting, mutliplying and dividing, examples can be created and checked by hand to ensure correctness. I tested cases as simple as 1/2 + 1/2 to mulple operation cases such as 1/3 + 1/4 - 1/12, as well as mixing multiply/dividing and adding/subtracting, such as 1/2 - 2/5 * 3/2. Each of these examples evaluated to the expected result, as well as the many other examples I tested. I ensured that dividing by a rational whose value was 0 was caught and handled appropriately, as well as performing all operations with negatives to ensure the results were correct and that the negative sign was always with the numerator instead of the denominator. Rather than test mostly simple cases such as dealing with postive Rationals, I tried to make a point of finding all edge cases and testing them to ensure that they were evaluated correctly. During my testing, I realized I hadn't accounted for dividing by a rational with 0 in the numerator, which caused a floating point exception. This allowed me to go back and create a solution to catch this problem. Because I had previously thought that I had managed all possible cases and then found an issue, I cannot be 100% certain that I have tested all edge cases. However, I am quite confident in the validity of my program because I tested all operations with negatives on both the right and left side of the operator, as well as using negatives in the numerator, denominator, and both. Every time, the result was as I had calculated by hand. This was also true for all cases involving 0, whether adding, subtracting, dividing, <, or >. Because of my testing by case and my thought into the possible cases and edge cases, and the fact that the expected correct values were displayed by my program in testing, I feel confident in the validity of the output of my program.


