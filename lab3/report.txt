Luke Garrison
Lab 3
Report.txt

This program is very easy for the end user to use. There are no options available at all, the only thing that the user can do is run the different driver programs that demo the different classes. What is more interesting to analyze, is the client's use of the classes that were created in this assignment. As specified, this report will focus on part 3. Since the user is only able to run the drivers that are demos, it is more interesting to look at the program from the client's perspective (programmer who is using the created class - ie possibly someone who is using the classes in their own driver program. As far as the Package example is concerned, a Package of class Package, OvernightPackage, or TwoDayPackage can be instantiated, eaching having access to the methods setWeight, setCostPerOunce, getCostPerOunce, getName, setName, getAddress, and setAddress. The each object of Package or its derived classes also has a calculateCost method, which returns the cost to ship that package. All of these methods would be useful for a client utilizing the Package class and its derived classes to store, analyze, and utilize package shipment information. 
Additionally, BankAccount and CreditCard were written using composition in part3. From a client's perspective, any BankAccount object, including the derived CreditCard class, has a print method, printing general account information, deposit, resetPin, getAccountNumber, setOwnerName, and getOwnerName. Additionally, the CreditCard class has an addCharge method to add charges to the account. 

From an internal perspective the Package class is a base class and has two derived classes: TwoDayPackage and OvernightPackage. Most of the core methods are built into the Package class, and are therefore shared with the two derived classes as well, such as getAddress and setName, as well as others. However, the calculateCost method is a virtual function in the base class and is defined in the derived classes. This creates a polymorphic base class, meaning a pointer of type base class pointing to one of the derived classes will execute the derived class' function instead of the the base class' implementation of the function. This enables the derived classes to have more precise and adjusted calculateCost functions to account for extra costs with their faster shipping rates. However, since the base class' virtual function also has an implementation (to return the cost calculated from only the weight of the package and the costPerWeight), this basic calculation can be utilized in the derived classes by specificaly calling the base class implementation within the derived class' function (such as Package::calculateCost()). This enables very succinct calculateCost definitions in the derived classes. 

The BankAccount and CreditCard in part 3 utilize composition instead of inheritance. This is done by instantiating a BankAccount object within the CreditCard class. This BankAccount's public methods can then be utilized to achieve the same end functionality as utilizing inheritance. One difference is that if dynamic memory allocation is used (using "new"), then a pointer to the base class object must be dereferenced any time the base class object is being called or used. I also found that even though the base class had a setOwnerName method, it could not be utilized without creating the same method in the previously derived class and then sending the arguments to the CreditCard object to the BankAccount object. I found this to add unnecessary complexity to the code. Nevertheless, all of the same functionality is still available.

To verify the program, I entered intentially invalid information in the driver program as parameters to the objects. I ensured that an error message would be displayed when the setWeight and setCostPerOunce functions took in a value. Since the driver program was totaling the cost of 6 different packages, I checked the total cost by hand to ensure it matched the program's output. I initially had an issue with the polymorphism, which resulted in the wrong total. I fixed this by using an array of pointers to Packages instead of an array of packages. After I made this adjustment, the total matched my hand calculation. I used the same philosophy with the BankAccount driver program for part 3. I ensured that all deposits and charges that were made in the driver program matched up to the calculations I performed by hand. Since they all did with various different sets of numbers, and also reported invalid input when negative numbers were specified for deposits or charges on the CreditCard, I believe my programs and classes were successfully verified. 

A unique component of my BankAccount class is that a random account number is automatically generated for each account (including derived classes). Thus, when a savings account is created, it will have a randomly generated account number which cannot be changed. This is done by randomly selecting an index from a string of all possible digits and adding one of these selected digits until the accountNumber string has the specified number of digits. 

The means of creating abstract vs concrete classes lies with the ability to make functions virtual. To create an abstract class, at least one function in the class must be a pure virtual function, meaning the function is labeled virtual and is also set equal to 0, such as virtual void deposit(double) = 0. The "= 0" component is what makes the virtual function "pure". Any class that is derived from an abstract class is also an abstract class unless every pure virtual function from the base class is defined (not equal to 0). Implementing the function that was a pure virtual function in the base class is the key to creating a concrete derived class from an abstract base class. It is important to note that if a base class has a virtual function that is not pure, then this base class would not be abstract unless it had a different virtual function that was pure.

Inheritance feels more natural to me from an implementation standpoint. Maybe I am making it overly complicated, but I do not like having to dereference a pointer to an object brought in via composition in order to utilize the object of the would-be-base class. However, I think it is very natural to use composition in certain scenarios, such as when creating a car. You would want to use four wheel objects, a steering wheel object, two mirror objects. However, I think it is more natural to utilize inheritance and create an abstract class called carPart, which will store basic information for any car part, such as model number, color, and cost to replace. This would give all derived carParts access to this information. While this is more natural to me because of the natural elegence of inheritance, it is important to note that it is still possible to accomplish this with any specific car part, say a Wheel. A wheel object would then contain via composition a CarPart object, and would still be able to set and get the values utilizing the CarPart class. However, this implementation is often more complicated than using inheritance, which is one of the main reasons I prefer to utilize inheritance. My main concern with inheritance is the dependency of all derived classes on their base classes. If a base class changes a return type of a method, then this will cause a ripple effect down through every derived class of this base class. For a large project, this minor tweak would have to be made in countless places, and would take a good amount of time to make all necessary changes accurately. I believe that this ripple effect would not occur if using composition, because the effect would propogate no futher than the class which is instantiating the "base class". Especially for smaller projects, I prefer to utilize the inheritance ideology.

Virtual functions are very similar to pure virtual functions. They can both be used to implement polymorphism. When a base class has a method marked as virtual, whether pure virtual or just virtual, then a derived class from this base class will have its method (assuming it defines the virtual method, with the same name) used instead of the base class' method if a pointer to the base class is used. The virtual option allows for dynamic binding, meaning that the type of object determines which method implementation is called at runtime. The difference between a virtual function and a pure virtual function is that a pure virtual function, even if it has an implementation, will make the class that it is in an abstract class (meaning that cannot be instantiated). A pure virtual function is indicated by setting itself to 0 (ie void setAddress() = 0) - the "= 0" is what indicates that the virtual function is pure. When a pure virtual function in a base class is present, it makes the base class abstract, and any derived class will also be abstract, unless it defines the pure virtual function of the base class. To utilize a virtual function for polymorphism purposes but without creating an abstract class, simply ensure that the virtual function(s) are not set equal to 0. The reason you would want to use pure virtual functions to create an abstract class is to model objects in a more sensible way. For example, if you want to capture common characteristics of many objects, but the container for these common characteristics are not sufficient to create an object, then an abstract class would be suitable. For example, as mentioned with the car example, you could create an abstract CarPart class, which would capture model numbers, colors, and more, and all derived classes would have these shared types of characteristcs. However, CarPart doesn't make sense to be an object itself, so this is why it would be an abstract class, sense it captures shared characteristics, but doesn't make sense to have an object of type CarPart. 


