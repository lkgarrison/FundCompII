Report.txt
Prelab
Luke Garrison

** pi.cpp **

From the user's perspective, the pi.cpp program is quite simple. The program asks the user how many terms should be used in the series that is used to estimate pi. The program will then check to make sure that the user's number is greater than or equal to 2. If it is not, the program will continue to prompt the user for a number greater than or equal to 2 until valid input is provided. After this, the pi estimation using 1 term, two terms, and so forth is displayed until the program displays the estimation using the user provided number of terms. 

This pi.cpp program has a rather simple structure. The variables (except the iterative variable i) are initialized at the beginning of main. Then, an always true while loop is used to continuously prompt the user for valid input. Within the while loop, there is an if statement used to check for valid input. If valid input is received, then the program breaks out of the while loop. At this point, the program will display the pi estimation for every possible number of terms between 1 term and the number of terms the user specified. Thus, the last line of the program will tell the user the estimation for pi using the specified number of terms in the estimation. It is also notable that the "pow" function from the cmath library is used in the estimation formula to control whether the next term in the series is positive or negative. Each term is simply added to the running sum, which improves in accuracy as more terms are added. 

I verified the program for correctness by preplanning the structure of the program on paper before typing the code, as well as testing with all possible user input. The user only has one chance to enter input (unless it is invalid). Thus, there is one input check to ensure the number entered is valid. The number must be >= 2, so I entered 3, 2, 1, 0, -55, and 77 to ensure that the output was as expected. For all numerical inputs less than 2, there was a prompt to enter another number until a valid number was entered. However, if the user were to enter a string of text instead of a number, such as "hello", then there will be an infinite loop. There was no clear way to account for this in my program. To ensure the calculations were coming out correctly, I did the first 5 terms by hand on my calculator and matched them up successfully with what was displayed via my program. By doing these things, I have verified the output of my program.

** mortgage.cpp mortgage.h main.cpp **

The main.cpp program is not really designed to work for the user. The Mortgage class makes it very easy to create mortgages and display the amortization schedule. However, the main.cpp program is simply used to demonstrate the methods and functionality of the Mortage class. If the driver program were more user friendly, it might for instance, prompt users for the principal, rate and payment instead of having to go into the code to adjust them. Thus, the user can only really do one thing: fix the principal, rate, and or payment if an invalid value was entered. When an invalid value is detected by the constructor, the user will be told what to do to provide a valid input. But this is more or less the user's only option the way main.cpp is set up. 

There is quite a bit going on internally. The main.cpp is simply a driver program that allows the Mortgage class to be put on display. In mortgage.h, the interface file for the Mortgage class, there is a list of methods that can be performed on a mortgage object, such as credit, getPrincipal, and amortize, in addition to the constructor, in addition to a list of private variables with one private function (needed internally, not by the client), such as principal, rate, payment, and interest. The private function is printHeader(), which is used to print the header row of the amortization table. The credit method takes in a payment amount and subtracts the remaining principal on the loan by the credited payment amount. The getPrincipal method simply returns the remaining principal. 

The most complicated method is the amortize method, which will print out an amortization table based on the principal, rate, and payment of the load. First, the month is set to 1 and the headers of the table columns are printed out. As long as the principal remaining is just barely greater than 0, the current month's interest is calculated and added to the principal. Then, the program checks to see if the remaining principal (acting as balance) is greater than the payment amount. If it is not, this means that the last payment is about to be made, and the payment is set to exactly the remaining principal. Then regardless, the payment amount is then subtracted from the principal. C++ std out is used to display the month number, the month's payment, interest, and principal remaining. setw is used to set the minimum width of the subsequent additon to the output stream. Using this function before each component of the table was printed allowed for a good amount of spacing in the amortization table. 

The final component to discuss is the constructor. I chose to use a non-default constructor with fallback values, rather than placing default values inside of a default constructor and also having a nondefault constructor to take the principal, rate and payment. This constructor provides input validation, ensuring that a principal > 0, rate >= 0, and payment > 0 are entered. The rate is also divided by 100 and also by 12 because the user and/or client will provide the rate as an annual percentage which will be converted to a monthly rate in decimal form. 

In main.cpp, four mortgages are created. The first with specified initialization values to display a short, clean amortization table. The second uses the fallback values of the constructor, and is also credited 10,000, and then has the remaining balance displayed. The third mortgage is set up so that the payment is too small and the user will be prompted to correct it. The fourth and final mortgage is initialized with invalid principal, rate, and payment, to demonstrate that the constructor will force the user to correct all three so that they are valid (and the payment will still have to be sufficiently large for the chosen principal and rate). Then the first and fourth mortgage objects have their amortization schedules displayed. 




program validation
