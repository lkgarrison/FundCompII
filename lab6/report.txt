Luke Garrison
report.txt
lab 6

The user has very little control of the program flow. When the user runs the program, the user is prompted for an input file for the initial sudoku solver. If the specified file does not exist, then the user is prompted for a valid file until a valid file name is provided or the user manually exits the program. After this, the program simply executes without any further interaction from the user. The initial sudoku puzzle is displayed, immediately follwed by the solved sudoku puzzle. The user should provide an input file that is a sudoku input file. The file should be organized similar to an actual sudoku puzzle, having n lines and n characters per line. 0's should be used when the initial puzzle's cell has no given value. The 0's are important to the implementation of the Puzzle class as they signify and unknown cell. 

The key to the implementation of the sudoku solver lies with a 3-D vector that tracks which values are possible in each cell on the puzzle. The first dimension of the vector is basically the row on the puzzle board, while the second dimension is the column. The 3rd dimension is a 3D vector with boardSize + 1 indicies. The first index of this 3rd dimension vector specifies the number that is currently in the cell. If the cell is unknown (ie a 0), then the first index is a 0. If the cell's value is known, it is stored in the first index of the vector. The next boardSize indicies store either a 0 or a 1 - 0 meaning that the index number (1 thru boardSize) (a value) is not a valid value for the cell, and vice versa. A 1 in index 4, for example, indicates that 4 is a possible value in the given cell. A 0 at index 5 indicates that 5 is not a possible value in the given cell. As such, displaying the value stored in puzzleVals[row][col][0] will display the current value of the cell, which is used in the display function. In the constructor, it is assumed that for every cell that is not given an intial value, all values are possible until values are eliminated. It is easiest to take the input file's values and translate them to a 2-D vector, which is then used to correctly build the possibleVals 3D vector, and the 2-D vector is no longer needed. It is mostly a matter of convenience in building the 3D vector. 

In the solve() method, two nested for loops are used to iterate through every index on the board until the board is solved. At every index on the board, getPossibles() is called to update the 3D possibleVals vector. This updated possibilities vector is then used by getCellVal() to try to get the current cell value by checking if the 3rd dimension of the possibleVals vector has only a single possible value for the cell. If there is only one possible value for the cell, then of course this possible value must be the value of the cell. markKnownCell() can then be called to update the possibilities vector when a cell is known. This funciton ensures that the possibleVals vector remains accurate by setting a known cell's 1st index in the 3rd dimension equal to its new value, and setting all other indicies except the index of its value to 0. However, with medium and hard puzzles, only filling in a cell when it has a single possible value is not sufficient to complete the puzzle, because this case doesn't happen enough. This is why a method to detect singletons is also necessary. 

The singleton method checks to see if there are any cells in either a row, col, or minigrid that have a possible value that no other cell has. For example, if in a given row, the second cell can have either a 1, 2, or 7, the third cell can have either a 2 or a 7, and the 4th cell can have either a 2 or a 7 (and all other cells in this row are known), then we know that the second cell must be a 1, because it is the only cell in the row that can possibly have a value of 1. This algorithm is used to detect singletons in rows, columns, and minigrids. The process for detecting a singleton in a row will be explained, which can then be extrapolated to understand how it was used with columns and minigrids. Given the current row and column being inspected, an outer for loop is used to iterate through every possible value in the sudoku. Another for loop is then used to iterate through all cells in the row. Then for each cell in the row, if the cell could possibly take a given value, then the number of cells that could have this current value is incremented. If the cell is the first cell in the row that can take on this value, its row and column are recorded, so that if it ends up being the only cell in the row that can take on this value, and the value in this cell is valid in the row, column, and minigrid, then its value can be set to this value and the possibilities vector can be updated. However, if more than one cell in the row could possibly take on the given value, then it is still inconclusive which cell should take on the value, and none of the cells are able to take it on with certainty yet.

These two methods of detecting which value a cell should take on lie at the heart of the sudoku solver algorithm. The single possible value detection combined with the singleton algorithm allow the program to solve many puzzles except for the hardest ones, which will require guessing some of the cells and backtracking if the guesses led to a dead end. My program does not work with sudoku puzzles of this difficulty. 

My program can be verified at the simplest level by providing the easy and medium puzzles and checking the outputed solution. I checked that all of the values in the original input puzzle were still in their correct places in the solution. I also checked many random values in the solution to make sure there were not any cells that violated the rules. I also input the input sudoku in an online solver and made sure my program's solution matched the online solution just to cross-check. Over the couse of writing my program, my program's output had minigrids with multiple occurances of the same value in a single minigrid. This issue puzzled me for a while, but then I realized I needed to make sure that before a cell's value is set via the singleton algorithm, it should be ensured that the value in the cell in question will produce a valid row, valid column, and valid minigrid. After making this change, the puzzles were solved correctly. Because both the easy and medium example puzzles were solved correctly, and this is probabistically impossible by random chance, I believe my program's output has been verified. 

In writing my program, I first started by tackling the easy puzzle case, where only the algorithm to determine the value of cells that have a single possible value is implemented (not the singleton algorithm). By writing this part of the solver first, I was sure that I had one component of the solver working correctly and without bugs. Then I could utilize my existing structure to add another algorithm to check for singletons. This worked very well because I knew what part of my program was causing errors because I was testing as I developed (spiral development). My design of the 3D possibleVals vector worked very well too, providing a clear and consise method to represent which values are possible for a given cell. 

Something that I am not satisfied with is the amount of hard-coded numbers in my program. 0's were hard-coded to check if a value was possible in a cell or not, similar to checking to see if an index in the possibleVals vector (3rd dimension) was equal to 1. I would have prefered to have been able to create a global/instance variable to represent 1's and 0's that I could have referred to instead of hard-coding these numbers in, as the program is less readable and less intuitive. As an update, I was able to edit my program using the constants POSSIBLE, NOT_POSSIBLE, KNOWN, and UNKNOWN. POSSIBLE and NOT_POSSIBLE refer to indicies 1-boardSize in the 3rd dimension of possibleVals, of whether or not the given value is possible in the cell or not. KNOWN and UNKNOWN refer to the first index of the 3rd dimension of possibleVals - whether or not the cell's value is known or not. KNOWN and POSSIBLE both equal 1, and UNKNOWN and NOT_POSSIBLE both equal 0. Four variables are used instead of 2 because the names help make their contextual use more sensible and readable. Something that I am surprised did not work is the example hard puzzle. I am not sure if this puzzle required guessing or not, but I was surprised to find that my singleton algorithm worked with the medium puzzle but not the hard puzzle. However, because the medium puzzle was the maximum difficulty required for full points on the lab and because I was unable to find the bug, I have left the program as is. I also realize that my mini-grid singleton code is not fully correct, because the singletonRow and column are ever only set between 0 and 2. i and j should be accounting for the topLeftX and the topLeftY, but I made a mistake. However, the code still works for the easy and medium puzzles as is. After attempting to fix the issue and only making the puzzle not get solved, I decided to leave the code as it stands. It actually works just as well to comment out the entire "mini-grid singleton" section, since it has a bug and isn't necessary anyway since the the row and column singleton algorithms work and are sufficient for the medium puzzle. 


