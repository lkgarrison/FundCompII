Luke Garrison
Lab 1 Report

Although this program is fairly complicated, it is quite simple from a user's standpoint. When the user runs main, the user is prompted of whether or not he/she would like to play against the computer (no means he/she would like to play against another human player). The user can then enter y for yes, or n for no. Any other keyboard input will prompt the user to enter valid input, y or n. If the user enters yes to play the computer, the user gets to make the first move. Immediately after the user selects a valid column, the computer will take its turn, and it will very quickly be the user's turn again. If the user enters a column that does not exist or a column that is full, an appropriate error message will be displayed to the user until valid input is entered. The game will then continue until either the game board gets full or either the user or the computer aquires 4 in a row on the board. The user's experience playing against another human is very similar to this. p1 is prompted to select a column first, and then p2 is prompted to select a column, instead of the computer automatically dropping a disc in a column. The game will then continue, with error checking on the inputs, until either one of the players gets 4 in a row, or the board has 0 free spaces remaining. 

Internally the program is vastly simplified by utilizing the features of object oriented programming. The connect4 board is actually composed of a set number of C4Col objects. The board class itself has certain methods, and the columns also have their own member functions. Since the board is basically an array of column objects, the board class is able to invoke the column objects' member functions. This is the thinking behind the design of this program. A main program is also used in order create an instance of the board class and play either the computer or another human player.

Most of the member functions of the C4Col class are quite simple, yet are a significant help when utilized in the play() and hasWon() methods. For example, the isFull() method will return 1 to indicate that the column is full, or a 0 to indicate that the column is not full. The getDisc() method will return what character/disc is in a specified row of the column. The getMaxDiscs() method basically sets the height of the connect4 board. It is commonly used so that the height of the board does not have to be hard coded throughout the C4Col and C4Board classes. The addDisc() method will add the specified piece in the next available row in the column. A member function that I added is the getNumDiscs() method, which returns the number of discs in the column. This was very valuable in my implementation of the hasWon() function to check to see if the most recent piece made the player/computer win. The function allowed the play() function to determine what row the most recent piece was placed into, so that the hasWon() function could check only around the most recently placed disc, since it is unnecessary to check for wins across the entire board. Instead of checking for 4 in a row across every possible space on the board each time a player dropped a disc, I instead created the hasWon() method to check and see if the most recent player's move successfully connected 4 discs. Since I implemented the extra credit computer, I will not go into too much detail. But the idea of the hasWon() method is to check to see if the most recently placed disc made 4 in a row horizontally, vertically, or via either diagonal (2 possible diagonals). I will explain process for the horizontal, which is the same process applied to the vertical and diagonal scenarios. For the horizontal scenario, The method first starts 3 spaces to the left of the column the disc was dropped in via an offset. If this space (the offset location) is in bounds on the board (a valid column), then the method will check to see if the player who dropped the last piece also has a piece in this slot. If so, it will check the next slot (and repeat this process up to 4 times). If at any point, the player's piece is not in a slot, the offset is adjusted by 1, and the process is repeated. This process of adjusting the offset will only occur until the offset is 0, then it will no longer repeat, or if 4 in a row is found. At a higher level, the first check occurs three spaces to the left of the column the piece was dropped in. The method will then check this slot and the 3 subsequent slots to check for matches. If any of them are missing the player's piece, the offset is adjusted 1 closer to the dropped column. Then it will check the next 4 in a row to see if all 4 contain the player's piece. Basically, it captures every horizontal possibility that the most recently placed piece could be a part of that would make 4 in a row. Again, this line of thinking was also applied to the vertical and diagonal scenarios. 

My approach for the extra credit, adding a mode to play the computer, involved altering main.cpp to allow the user to choose which mode to play in, as well as creating a playComputer() function for the user to play the computer. The key difference between play() and playComputer() is that play() expects human input for both players, while playComputer() must randomly generate the computer's column selection, as long as this random choice is valid and the column is not full. But for the most part, the methods are very similar. Other small differences include the message that is displayed if the computer wins and the sturcturing within the while loop. Otherwise, the logic is very similar, as the computer is basically treated the same as p2 except that the user is not given the opportunity to enter a column selection on the computer's turn - the computer will simply place a disc randomly and immediately. I decided it was best to create a separate method, even though there is similar code, because it is more important for the user to be able to easily chose which mode is being played. Another alternative might be to prompt the user to choose which mode is to be played within the constructor. However, for this assignment, I didn't feel that it made a significant different either way. If the C4Board class were to be used inside another class, this might not be preferable. Additionally, it could be easier for the graders to tweak the code by putting this logic in main.cpp, basically like a demo of the C4Board class. Thus, having the play() function written in an organized, logical way significantly helped the task of creating another method to play the computer. 

The verification for this lab was tricky, because on a 7x6 board, there are a very large number of comibinations of piece placements, and there is no simple way to verify that your program performs correctly under every circumstance. One of the things that helped me the most was to sketch out the board when I was coming up with the hasWon() function, and use the board to create an efficient algorithm to check for wins. I thought about my solution for a long time, ensuring the method would not access rows/columns that were out of bounds, and would always check exacty enough to ensure that 4 in a row was/was not met. I was very careful as I ported my idea into code, double and triple checking to make sure that I would not be off by even 1 column anywhere. But even as hard as I tried, I still found bugs after the implementation was finished. For example, through testing, I happened upon a bug where the program thought there was a winner if you got 3 in a row diagonally, with the first and last piece in the line touching a different edge of the board (hard to describe the piece placement). I found a simple, yet overlooked aspect of my method was responsible. Thus, testing is really a vital way to validate code. But I didn't simply test scenarios that I knew would work. I tested all kinds of scenarios, such as having 3 in a row up against the edge of the screen, having 5+ in a row with only 1 piece missing in the middle, playing in full columns, choosing non-existant columns. After I had played many times, both against myself and against my computer version, and ensured that the game had ended when someone got 4 in a row and never prematurely, I was able to safely say that the code had been thoroughly validated. 

It is important to use getter methods for a number of reasons. Some of the most important are controlling the program flow and ensuring that the program's variables are not able to be tampered with, whether accidentally or maliciously. By forcing the client of a class to use a getter method to access a variable, you are preventing them from being able to set the variable. For example, you can make maxDiscs in the C4Col class private so that no one can randomly adjust the column heights. Similarly, because you have to use getDisc() to know what character is in a certain row of a column, this character cannot be changed directly. The class does not allow any way to change a disc that is already in a column. So there are no undo's and it also prevents cheating by converting already placed discs. Even more explicitely, think about a bank account balance. Would the bank want an account's balance to be public so that anyone could set their account balance to be whatever they want? Of course not! Using getter methods allows the class to control the flow of information and the security of the information. Forcing a getter method to be used can also allow for error checking to be performed, rather than allowing direct access. 

Dynamic memory management allows the size of an object to be determined at execution time. There is a significant advantage to doing this: you don't have to hard code, for example, array sizes into your program. Instead, you can use the keyword "new" to create a dynamically allocated array whose size could be set to the size specified by a variable. Especially with larger programs, this can safe a significant amount of space. However, using "new" to allocate memory dynamically still requires memory. And if a lot of memory is allocated, there could eventually be a shortage. If the memory is not being returned to the system when it is no longer needed, this is generally called a memory leak. However, if all memory that is dynamically allocated gets freed when it is no longer needed, then the program can theoretically run infinitely (as long as the objects are actually eventually deleted), and, without any memory leaks, it should still have memory left. Think of a program that allows you to draw shapes. If you delete the shape you just drew, then you would expect all of the memory associated with the shape to be returned to the system, since the shape was deleted. Deconstructors are an important means of freeing the memory allocated dynamically. Without a deconstructor, the memeory dynamically allocated for the object will stay in memory (a memory leak). But a deconstror can be used to tell the memory that was dynamcically allocated to be freed when the object is destroryed. 


I would like to briefly discuss on a feature I added to my C4Board class, the ability to detect if the board is full (no remaining moves). I knew one way I could do this was check every space on the board and see if any of the spaces were still blank (starting from the top, of course, to be more efficient). Instead, each time a disc is dropped into a column, that column is checked to determine if it is full. If it is, then the variable that keeps track of the number of full columns is incremented. Note that a simple count is all you need, because after a column is full, the count will be incremented, and then this full column can never be selected again, because of input checking (the computer's random selection is also checked). This means that at the most, the isFull() method is called 42 times for a 7,6 grid, instead of checking all (or at least some of) the 42 slots 42 times (once for each move). Thus, the game is ended and declared a draw when the number of full columns is equal to the number of columns. 




