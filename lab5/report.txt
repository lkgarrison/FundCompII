Luke Garrison
Lab 5
report.txt

Part 1: Lab5 repository: https://github.com/lkgarrison/FundCompII/tree/master/lab5
	The FundCompII repository contains folders (branches) for all previous labs as well.

The user's interaction with the program is fairly straightforward. A very simple main.cpp is used as a driver program to create a sudoku puzzle (puzzle of type int). Then, the play member function of the puzzle is called to initiate the interactive mode for the user. At this point, the user is required to enter a valid filename that serves as the base initialization for the puzzle. The filename will be checked to ensure that it exists, and if it does (assuming a valid, meaningful file was specified), the initial sudoku will be displayed along with general instructions, such as entering "-1" at any time to quit, and entering a value of 0 in a cell to erase the value. While the user's interface is clean, there is a lot of checking that goes on behind the scenes, which will alert the user if an invalid row, column, or value was specified. The user is sequentially prompted for the row and column to adjust, and then the value to place in the specified location. However, if the user specifies the location of a value that was from the original setup of the puzzle, the user will be notified and unable to change the value (the puzzle must be solved with respect to the initial pieces - they cannot be changed because that defeats the purpose of the puzzle). Additionally, if the user specified a value for a location and that value already exists in the same row, column, or mini-grid, the user is notified and prompted to choose a new location and/or value. If the user attempts to access a location "off the puzzle board" (that doesn't exists), the user will similarly be notified and re-prompted. Additionally, the user will see a rather nice looking display of the sudoku, as the "mini-grids" have been made distinct using pipe and hyphen characters. Thus, the sudoku board looks more realistic and also readable from the user's perspective. 

From the programmer's perspective, this program was created utilizing object oriented design as well as a templated class. As with every class, there is a constructor. In the Puzzle class, the constructor has a fallback value of 9 for the size of the puzzle. The constructor then sets the boardSize variable to the size of the puzzle specified from the constructor's parameter. Additionally, the constructor creates an ifstream object, gets a valid file name from the user, and then attempts to open the file. If the file does not exist, then the user is prompted to enter a new filename until it exists or the user exits the program. Importantly, the open method of the ifstream object requires a c string, not a c++ string, so the c++ file name string is converted via the string method c_str(). Then, until the end of the file is reached, a vector of type T is created matching the current row of the puzzle. Each non-whitespace character from the input file is read in and saved to singlePuzzlePiece, and then is pushed to the back of the vector "row". Then this row is added to both 2-D vectors representing the originalPuzzle and the puzzle. This is done for the entire data file. The reason for the originalPuzzle and puzzle 2-D vectors is that the originalPuzzle stores the initial values for the puzzle, and is never changed after the constructor is run. However, when the user attempts to set a cell on the puzzle, originalPuzzle can be used to check if the user is attempting to alter a value that was set on the initial puzzle setup, and then the change can be denied to ensure the integrity of the puzzle. "puzzle" is the vector that is adjusted when the user does make changes to the puzzle, and is also the puzzle that gets displayed after each move.

The puzzle class contains two important public methods: play and display. The class also contains a number of private methods that are helper functions, and would be of no use to a client. Such helper methods include displaying a row of dashes, checking if row, column, and minigrid placement is valid, and counting the number of remaining spaces on the puzzle. 

The play method immediately calls display() to display the puzzle at the top of the terminal, followed by a line of basic instructions. Notably, there is a "sentinel" variable which is the value the user should enter to quit the program. This variable is used instead of hard coding a value into the code. a boolean flag called doQuit is used to determine if the user entered the sentinel value at any point, and is checked to exit the programm immediately if the sentinel value was entered. A loop that will exit if the user finishes the puzzle or if the user specifies the sentinel value is used to allow the user to complete the puzzle. The user is prompted for a valid row, column and value, sequentially. Each is checked before prompting for the next, checking to ensure that the row/col/value is valid for the given puzzle, as well as checking to see if the user entered the sentinel value. If the user entered the sentinel, the flag is checked and the loop will be exited, ending the game. However, if the row/col/value is simply invalid, the user will be continuously prompted for a valid input (including the sentinel). The row, col, and value all have very similar logic. The primary difference is that the row and column specification from the user are decremented by 1, because the user will provide locations starting at 1, not 0, because this is more convenient and intuitive for the user. However, the internal representation begins at 0, which is why the conversion must take place. Next, the row, col, and value are passed to the three helper functions to ensure that the placement in the row, column, and minigrid are valid. If they are, then the value at that location on the puzzle is adjusted accordingly and the puzzle is redisplayed, if not, the outer loop continues back at the beginning. 

The isValidRow and isValidCol methods are quite simple. They hold either the row or the column constant, respectively, and iterate through the puzzle for all combinations of the other parameter, checking to see if the user specified value exists anywhere in the row or column. If it does, an appropriate error message is displayed and false is returned. If the value is unique to the row or column, it returns true; The isValidMiniGrid is very similar, but must check a minigrid instead, which is more complicated than the row. The key to this method is finding the row and column of the top left corner of the minigrid that the row and column specified by the user is in. Then, every cell in that minigrid (for a 9x9 sudoku, all 9 cells) are checked, from left to right and top to down. If any of these locations matches the value, an error message is displayed, but if not, it returns true.

countRemainingSpaces is a very simple method that simply iterates through the entire puzzle board, checking for 0's. It counts the number of 0's (blanks) on the board, and returns this number. This method is actually very similar to the display method, only the display method has more logic within it to enable to nice sudoku-like display, separating the mini-grids. First, the terminal screen is cleared, and then the top boarder of dashes is displayed. Then, a for loop iterates through every row. An if statement checks to see if the current row should have a row of dashes displayed (starting with the first row, they should be displayed every 3 rows (or every sqrt(boardSize) rows)). Then, every piece in the row is displayed. Starting with the first piece, if every three pieces, a "|" should be displayed between the pieces to form the minigrid. If the piece is equal to 0, then display only a space instead, but otherwise display the piece. After the row has been displayed, the right boarder should be displayed, followed by a newline to set up the next line. After all rows have been displayed, another row of dashes should be displayed to complete the bottom boarder of the puzzle. These extra checks that have been described allow for the addition of the minigrid in the puzzle's display. 

Something I do not think worked quite well enough lies within the templated class itself. The Puzzle class is templated, but largely with int's and char's in mind. Even though the sudoku (Puzzle<int>) works very well, the current implementation is not 100% compatible with chars. A wordoku can be read in and displayed, but not completely correctly. For example, because wordoku's have an extra line with the characters that the puzzle contains and sudoku's don't and I could find no way to read in an extra line only when the Puzzle is of type char instead of int, I was unable to accomodate this discrepancy. Additionally, the 0's in the wordoku are read as the character 0, not the number 0, so the checks to see if a  piece in the puzzle is equal to 0 does not work. I could find good way to convert from '0' to 0 that would be compatible with both a sudoku and a wordoku. However, if I could find solutions so these two problems, I believe the Puzzle class would be fully functional for a wordoku. 

One component I think worked very well and am very satisfied with is the display of the puzzle. Whether it is a 9x9 puzzle or a 16x16 puzzle, or any size sudoku puzzle, the minigrids are correctly created to help the player see the puzzle more easily. This added feature of my Puzzle class turned out very well. 

Because templating was added to C++ later, it is easiest create a templated class by providing the implementatino in the same .h header file as the interface. Thus, at the top of the file, it looks like a regular interface file, with the addition of "template <typename T>" above the class definition. However, after the class definition, each method in the class definition has its implementation below the a line reading "template <typename T>. Other than using "T" instead of a specific type (ie int or char) when appropriate, this program is very similar to previous programs. 


This program was verified by attempting to break the code in every way I could think of. I entered rows and columns that were out of bounds, ensuring an appropriate error message was displayed as well as being reprompted. I also tried values that did not exist in the sudoku. Importantly, I chose cells randomly on the puzzle and randomly chose a value for the cell and manually checked the row, column, and mini-grid to see if the value should work or not. I also worked through the puzzle for a while, making sure it was taking all of the values I had worked out. Because I had spent a lot of time checking through my logic and doing incremental testing, I did not encounter many issues when testing the whole puzzle. I did find a few minor bugs, such as having changed the puzzle type to char and forgetting to change it back to int when testing the sudoku again. However, after visualizing the row, column, and mini-grid checks, I ensured that their logic was correct before and after coding these helper functions. The main while loop in the play method took some tweaking, especially to ensure that I could enter a value of -1 at any time to completely end the sudoku puzzle. However, I tested entering my sentinel of -1 in the row, column, and value fields many times over and it worked every time. The final component to test was ensuring that the puzzle was detecting being completed correctly. I decided to use the thinking that every piece must be checked as it is input, and when the final piece is added, if it was successfully added, the whole puzzle must be correct, assuming a valid initial data file. To make testing easier, I used an online solver to solve the puzzle, then created a test file with the solved sudoku input, replaced a few values with 0's, and then used this file with my program. Every time, as soon as I entered the last missing value, the program correctly ended. However, if until I entered a correct value for this last cell, it would not say that I had solved the puzzle. I encountered a bug here because I forgot to initialize a counter to 0, so when I was counting the number of missing values in the puzzle, it was often randomly incorrect, and until I initialized the counter to 0, I was not getting the correct program flow. The last nice addition to my puzzle class is that if a value of 0 is ever specified for a piece, then the current piece (as long as it is not part of the original puzzle skeleton) would be removed and cause the puzzle to display that space with blank space until set again. This allowed for more natural "erasing" in the sudoku, as a real puzzle might be solved. 
